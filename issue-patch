diff --combined src/block-cipher.h
index 0925595,bc2b99c..0000000
--- a/src/block-cipher.h
+++ b/src/block-cipher.h
@@@ -1,12 -1,13 +1,57 @@@
  #include "parallel-scatter.h"
 -  // encrypt block cipher
 -    static void puzzleEncryptFileWithHeader(
 -        const std::string &inFilename,
 -        const std::string &outFilename,
 +
++
++/**
++ * A helper to print out the puzzle encryption parameters for debugging.
++ * This will ensure the logs appear when run under wasm.
++ */
++static void debugPrintPuzzleParams(
++    const std::vector<uint8_t>& plainData,
+     const std::string& key,
+     HashAlgorithm algot,
+     uint32_t hash_size,
 -        uint64_t seed,             // Used as IV
 -        std::vector<uint8_t> salt, // Provided salt
++    uint64_t seed,
++    const std::vector<uint8_t>& salt,
++    size_t blockSize,
++    size_t nonceSize,
++    const std::string& searchMode,
++    bool verbose,
++    bool deterministicNonce,
++    uint32_t outputExtension)
++{
++  std::cerr << "[puzzleEncryptBufferWithHeader - DEBUG]\n"
++            << "  plainData.size(): " << plainData.size() << "\n"
++            << "  key: \"" << key << "\" (length: " << key.size() << ")\n"
++            << "  algot: " << ((algot == HashAlgorithm::Rainbow) ? "Rainbow" :
++                                (algot == HashAlgorithm::Rainstorm ? "Rainstorm" : "Unknown")) << "\n"
++            << "  hash_size (bits): " << hash_size << "\n"
++            << "  seed (iv): " << seed << "\n"
++            << "  salt.size(): " << salt.size() << "\n"
++            << "  blockSize: " << blockSize << "\n"
++            << "  nonceSize: " << nonceSize << "\n"
++            << "  searchMode: \"" << searchMode << "\"\n"
++            << "  verbose: " << (verbose ? "true" : "false") << "\n"
++            << "  deterministicNonce: " << (deterministicNonce ? "true" : "false") << "\n"
++            << "  outputExtension: " << outputExtension << "\n";
++
++  // Optionally print the first few bytes of salt to confirm
++  if (!salt.empty()) {
++    std::cerr << "  Salt bytes (up to 16): ";
++    for (size_t i = 0; i < salt.size() && i < 16; i++) {
++      std::cerr << std::hex << (int)salt[i] << " ";
++    }
++    std::cerr << std::dec << "\n";
++  }
++}
++
++
 +static std::vector<uint8_t> puzzleEncryptBufferWithHeader(
 +  const std::vector<uint8_t> &plainData,
 +  const std::string &key,
 +  HashAlgorithm algot,
 +  uint32_t hash_size,
 +  uint64_t seed,
 +  const std::vector<uint8_t> &salt,
    size_t blockSize,
    size_t nonceSize,
    const std::string &searchMode,
@@@ -14,121 -15,147 +59,128 @@@
    bool deterministicNonce,
    uint32_t outputExtension
  ) {
 -        if (hash_size / 8 + outputExtension > 65536) {
 -          std::cerr << "[Warning] Total output length ("
 -                      << hash_size / 8 + outputExtension
 -                      << ") exceeds the cap of 65536 bytes.\n";
 -          outputExtension = std::min(outputExtension, 65536 - hash_size / 8);
 -          std::cerr << "[Warning] Capping outputExtension to " << outputExtension << "\n" ;
 -        }
 -        // 1) Read & compress plaintext
 -        std::ifstream fin(inFilename, std::ios::binary);
 -        if (!fin.is_open()) {
 -            throw std::runtime_error("Cannot open input file: " + inFilename);
 -        }
 -        std::vector<uint8_t> plainData(
 -            (std::istreambuf_iterator<char>(fin)),
 -            (std::istreambuf_iterator<char>())
 -        );
 -        fin.close();
 -
  #ifdef _OPENMP
    int halfCores = std::max(1, 1 + static_cast<int>(std::thread::hardware_concurrency()) / 2);
    omp_set_num_threads(halfCores);
  #endif
  
 -        auto compressed = compressData(plainData);
++  // 0) Print debug info about all parameters
++  debugPrintPuzzleParams(
++      plainData, key, algot, hash_size, seed,
++      salt, blockSize, nonceSize, searchMode,
++      verbose, deterministicNonce, outputExtension
++  );
+ 
 -        plainData = std::move(compressed);
 +  // 1) Compress plaintext
 +  //auto compressed = compressData(plainData);
 +  auto compressed = plainData;
  
 -        // 2) Prepare output & new FileHeader
 -        std::ofstream fout(outFilename, std::ios::binary);
 -        if (!fout.is_open()) {
 -            throw std::runtime_error("Cannot open output file: " + outFilename);
 -        }
 +  // 2) Prepare output buffer
 +  std::vector<uint8_t> outBuffer;
 +  outBuffer.reserve(compressed.size() + 1024); // Just a guess to reduce re-allocs
  
 -        // 3) Determine searchModeEnum based on searchMode string
 -        uint8_t searchModeEnum = 0xFF; // Default for Stream Cipher Mode
 -        if (algot == HashAlgorithm::Rainbow || algot == HashAlgorithm::Rainstorm) { // Only for Block Cipher Modes
 +  // 3) Determine searchModeEnum
 +  uint8_t searchModeEnum = 0xFF; // Default for Stream (not used), but we'll set properly
 +  if (algot == HashAlgorithm::Rainbow || algot == HashAlgorithm::Rainstorm) {
      if (searchMode == "prefix") {
        searchModeEnum = 0x00;
 -            }
 -            else if (searchMode == "sequence") {
 +    } else if (searchMode == "sequence") {
        searchModeEnum = 0x01;
 -            }
 -            else if (searchMode == "series") {
 +    } else if (searchMode == "series") {
        searchModeEnum = 0x02;
 -            }
 -            else if (searchMode == "scatter") {
 +    } else if (searchMode == "scatter") {
        searchModeEnum = 0x03;
 -            }
 -            else if (searchMode == "mapscatter") {
 +    } else if (searchMode == "mapscatter") {
        searchModeEnum = 0x04;
 -            }
 -            else if (searchMode == "parascatter") {
 +    } else if (searchMode == "parascatter") {
        searchModeEnum = 0x05;
 -            }
 -            else {
 +    } else {
        throw std::runtime_error("Invalid search mode: " + searchMode);
      }
    }
  
 -        // 4) Build the new FileHeader
 +  // 4) Build FileHeader
    FileHeader hdr{};
    hdr.magic = MagicNumber;
 -        hdr.version      = 0x02;       // New version
 -        hdr.cipherMode   = 0x11;       // 0x11 for “Block Cipher + puzzle”
 +  hdr.version = 0x02;
 +  hdr.cipherMode = 0x11; // "Block Cipher + puzzle"
    hdr.blockSize = static_cast<uint8_t>(blockSize);
    hdr.nonceSize = static_cast<uint8_t>(nonceSize);
    hdr.outputExtension = outputExtension;
 -        std::cout << "Output ext" << outputExtension << std::flush;
    hdr.hashSizeBits = hash_size;
    hdr.hashName = (algot == HashAlgorithm::Rainbow) ? "rainbow" : "rainstorm";
 -        hdr.iv           = seed;       // The seed as our “IV”
 -
 -        // 5) Assign provided salt
 +  hdr.iv = seed;
    hdr.saltLen = static_cast<uint8_t>(salt.size());
    hdr.salt = salt;
 -
 -        // 6) Assign original (compressed) size
 -        hdr.originalSize = plainData.size();
 -
 -        // 7) Assign searchModeEnum
 +  hdr.originalSize = compressed.size();
    hdr.searchModeEnum = searchModeEnum;
  
 -        // 8) Write the unified header
 -        writeFileHeader(fout, hdr);
 -
 -        // 9) Prepare puzzle searching
 -        size_t totalBlocks = (hdr.originalSize + blockSize - 1) / blockSize;
 -        int progressInterval = 1'000'000;
 -
 -        // 10) Derive a “master PRK” from (seed, salt, key)
 -        // Using your iterative KDF
 +  // 5) Write the header into outBuffer
 +  {
 +    // We'll mimic writeFileHeader but do it directly into outBuffer
 +    // (You could factor out a writeHeaderToMemory if you prefer.)
 +    auto writeVec = [&](const void* ptr, size_t len) {
 +      const uint8_t* p = static_cast<const uint8_t*>(ptr);
 +      outBuffer.insert(outBuffer.end(), p, p + len);
 +    };
 +
 +    writeVec(&hdr.magic, sizeof(hdr.magic));
 +    writeVec(&hdr.version, sizeof(hdr.version));
 +    writeVec(&hdr.cipherMode, sizeof(hdr.cipherMode));
 +    writeVec(&hdr.blockSize, sizeof(hdr.blockSize));
 +    writeVec(&hdr.nonceSize, sizeof(hdr.nonceSize));
 +    writeVec(&hdr.hashSizeBits, sizeof(hdr.hashSizeBits));
 +    writeVec(&hdr.outputExtension, sizeof(hdr.outputExtension));
 +    uint8_t hnLen = static_cast<uint8_t>(hdr.hashName.size());
 +    writeVec(&hnLen, sizeof(hnLen));
 +    if (hnLen > 0) {
 +      writeVec(hdr.hashName.data(), hnLen);
 +    }
 +    writeVec(&hdr.iv, sizeof(hdr.iv));
 +    writeVec(&hdr.saltLen, sizeof(hdr.saltLen));
 +    if (hdr.saltLen > 0) {
 +      writeVec(hdr.salt.data(), hdr.saltLen);
 +    }
 +    writeVec(&hdr.searchModeEnum, sizeof(hdr.searchModeEnum));
 +    writeVec(&hdr.originalSize, sizeof(hdr.originalSize));
 +    // hmac left zero-initialized, if you use it
 +    writeVec(hdr.hmac.data(), hdr.hmac.size());
 +  }
 +
 +  // 6) Derive PRK
    std::vector<uint8_t> keyBuf(key.begin(), key.end());
 -        // Convert seed (uint64_t) to vector<uint8_t>
    std::vector<uint8_t> seed_vec(8);
    for (size_t i = 0; i < 8; ++i) {
      seed_vec[i] = static_cast<uint8_t>((seed >> (i * 8)) & 0xFF);
    }
 +  std::vector<uint8_t> prk = derivePRK(seed_vec, salt, keyBuf, algot, hash_size);
  
 -        std::vector<uint8_t> prk = derivePRK(
 -            seed_vec,          // Converted seed as vector<uint8_t>
 -            salt,              // Provided salt
 -            keyBuf,            // IKM (Input Key Material)
 -            algot,             // Hash algorithm
 -            hash_size          // Hash size in bits
 -        );
 -
 -        // 11) Extend that PRK into subkeys for each block
 -        // Each subkey is hash_size/8 bytes
 +  // 7) Extend PRK into subkeys
 +  size_t totalBlocks = (hdr.originalSize + blockSize - 1) / blockSize;
    size_t subkeySize = hdr.hashSizeBits / 8;
    size_t totalNeeded = totalBlocks * subkeySize;
 -        std::vector<uint8_t> allSubkeys = extendOutputKDF(
 -            prk,
 -            totalNeeded,
 -            algot,
 -            hdr.hashSizeBits
 -        );
 +  std::vector<uint8_t> allSubkeys = extendOutputKDF(prk, totalNeeded, algot, hdr.hashSizeBits);
  
 -        // 12) Initialize RNG for non-deterministic nonce generation
 +  // 8) Setup for puzzle searching
    std::mt19937_64 rng(std::random_device{}());
    std::uniform_int_distribution<uint8_t> dist(0, 255);
    uint64_t nonceCounter = 0;
 -
    size_t remaining = hdr.originalSize;
 -        // For mapscatter arrays
 -        uint8_t reverseMap[256 * 256] = {0};
 -        uint8_t reverseMapOffsets[256] = {0};
 -        std::bitset<256 * 256> usedIndices;
 +  int progressInterval = 1'000'000;
  
 -        // 13) Iterate over each block to perform puzzle encryption
 +  // We'll store encryption results in outBuffer after the header
    for (size_t blockIndex = 0; blockIndex < totalBlocks; blockIndex++) {
      size_t thisBlockSize = std::min(blockSize, remaining);
      remaining -= thisBlockSize;
  
 -            // Extract this block
 +    // Extract block
      std::vector<uint8_t> block(
 -                plainData.begin() + blockIndex * blockSize,
 -                plainData.begin() + blockIndex * blockSize + thisBlockSize
 +      compressed.begin() + blockIndex * blockSize,
 +      compressed.begin() + blockIndex * blockSize + thisBlockSize
      );
  
 -            // Extract subkey for this block
 -            const size_t offset = blockIndex * subkeySize;
 +    // Extract subkey
 +    size_t offset = blockIndex * subkeySize;
      if (offset + subkeySize > allSubkeys.size()) {
        throw std::runtime_error("Subkey index out of range.");
      }
@@@ -137,50 -164,57 +189,50 @@@
        allSubkeys.begin() + offset + subkeySize
      );
  
 -            // -----------------------
 -            // parascatter branch
 -            // -----------------------
 -
 -            if (searchModeEnum == 0x05) { // parascatter
 +    // If parascatter
 +    if (searchModeEnum == 0x05) {
        auto result = parallelParascatter(
 -                    blockIndex,             // Current block index
 -                    thisBlockSize,          // Size of this block
 -                    block,                  // Block data
 -                    blockSubkey,            // Subkey for this block
 -                    nonceSize,              // Nonce size
 -                    hash_size,              // Hash size in bits
 -                    seed,                   // Seed
 -                    algot,                  // Hash algorithm
 -                    deterministicNonce,     // Deterministic nonce flag
 -                    outputExtension         // how much output is extended by per block
 +        blockIndex,
 +        thisBlockSize,
 +        block,
 +        blockSubkey,
 +        nonceSize,
 +        hash_size,
 +        seed,
 +        algot,
 +        deterministicNonce,
 +        outputExtension
        );
 -
 -                // Write the nonce and scatter indices
 -                fout.write(reinterpret_cast<const char*>(result.chosenNonce.data()), nonceSize);
 -                fout.write(reinterpret_cast<const char*>(result.scatterIndices.data()), result.scatterIndices.size() * sizeof(uint16_t));
 -
 -                // Progress Reporting
 -                std::cerr << "\r[Enc] Mode: parascatter, Block " << (blockIndex + 1)
 -                          << "/" << totalBlocks << " " << std::flush;
 +      // Write nonce
 +      outBuffer.insert(outBuffer.end(), result.chosenNonce.begin(), result.chosenNonce.end());
 +      // Write scatter indices
 +      {
 +        const uint8_t* si = reinterpret_cast<const uint8_t*>(result.scatterIndices.data());
 +        outBuffer.insert(outBuffer.end(), si, si + result.scatterIndices.size() * sizeof(uint16_t));
        }
 -
 -            // ------------------------------------------------------
 -            // other modes in else branch
 -            // ------------------------------------------------------
 -            else {
 -                // We'll fill these once a solution is found
 +      if (verbose) {
 +        std::cerr << "\r[Enc] Mode: parascatter, Block " << (blockIndex + 1) << "/" << totalBlocks << " ";
 +      }
 +    } else {
 +      // Other modes
        bool found = false;
        std::vector<uint8_t> chosenNonce(nonceSize, 0);
        std::vector<uint16_t> scatterIndices(thisBlockSize, 0);
  
        for (uint64_t tries = 0; ; tries++) {
 -                    // Generate the nonce
 +        // Generate nonce
          if (deterministicNonce) {
            for (size_t i = 0; i < nonceSize; i++) {
              chosenNonce[i] = static_cast<uint8_t>((nonceCounter >> (i * 8)) & 0xFF);
            }
            nonceCounter++;
 -                    }
 -                    else {
 +        } else {
            for (size_t i = 0; i < nonceSize; i++) {
              chosenNonce[i] = dist(rng);
            }
          }
  
 -                    // Build trial buffer
 +        // Build trial
          std::vector<uint8_t> trial(blockSubkey);
          trial.insert(trial.end(), chosenNonce.begin(), chosenNonce.end());
  
@@@ -188,23 -222,42 +240,23 @@@
          std::vector<uint8_t> hashOut(hash_size / 8);
          invokeHash<false>(algot, seed, trial, hashOut, hash_size);
  
 -                    // If outputExtension > 0, extend the output
 -                      std::vector<uint8_t> finalHashOut = hashOut; // Default to OG hashOut
 +        // Possibly extend output
 +        std::vector<uint8_t> finalHashOut = hashOut;
          if (outputExtension > 0) {
 -                        // Derive PRK using trial, salt, and seed
 -                        /*
 -                        std::vector<uint8_t> prk = derivePRK(
 -                          trial,              // Input key material: subkey || nonce
 -                          salt,               // Salt from encryption call
 -                          keyBuf,             // IKM from encryption call
 -                          algot,              // Hash algorithm
 -                          hash_size           // Base hash size
 -                        );
 -                        */
 -
 -                        // Extend the PRK to derive additional bytes (extendedOutput)
 -                        size_t extendedSize = outputExtension; // Additional bytes required
 -                        std::vector<uint8_t> extendedOutput = extendOutputKDF(
 -                          trial,                // PRK derived from trial
 -                          extendedSize,       // Length of the extension
 -                          algot,              // Hash algorithm
 -                          hash_size           // Original hash size
 -                        );
 -
 -                        // Combine hashOut and extendedOutput
 +          // For demonstration, use the subkey+nonce as the "PRK" input
 +          std::vector<uint8_t> extendedOutput = extendOutputKDF(trial, outputExtension, algot, hash_size);
            finalHashOut.insert(finalHashOut.end(), extendedOutput.begin(), extendedOutput.end());
          }
  
 +        // Check the search mode
          if (searchModeEnum == 0x00) { // prefix
            if (finalHashOut.size() >= thisBlockSize &&
                std::equal(block.begin(), block.end(), finalHashOut.begin())) {
              scatterIndices.assign(thisBlockSize, 0);
              found = true;
            }
 -                    }
 -                    else if (searchModeEnum == 0x01) { // sequence
 -                        for (size_t i = 0; i <= finalHashOut.size() - thisBlockSize; i++) {
 +        } else if (searchModeEnum == 0x01) { // sequence
 +          for (size_t i = 0; i + thisBlockSize <= finalHashOut.size(); i++) {
              if (std::equal(block.begin(), block.end(), finalHashOut.begin() + i)) {
                uint16_t startIdx = static_cast<uint16_t>(i);
                scatterIndices.assign(thisBlockSize, startIdx);
@@@ -212,9 -265,9 +264,9 @@@
                break;
              }
            }
 -                    }
 -                    else if (searchModeEnum == 0x02) { // series
 +        } else if (searchModeEnum == 0x02) { // series
            bool allFound = true;
 +          std::bitset<256 * 256> usedIndices;
            usedIndices.reset();
            auto it = finalHashOut.begin();
  
@@@ -229,7 -282,8 +281,7 @@@
                    break;
                  }
                  ++it;
 -                                }
 -                                else {
 +              } else {
                  allFound = false;
                  break;
                }
@@@ -239,12 -293,20 +291,12 @@@
                break;
              }
            }
 -
            if (allFound) {
              found = true;
 -                            if (verbose) {
 -                                std::cout << "Series Indices: ";
 -                                for (auto idx : scatterIndices) {
 -                                    std::cout << static_cast<uint16_t>(idx) << " ";
            }
 -                                std::cout << std::endl;
 -                            }
 -                        }
 -                    }
 -                    else if (searchModeEnum == 0x03) { // scatter
 +        } else if (searchModeEnum == 0x03) { // scatter
            bool allFound = true;
 +          std::bitset<256 * 256> usedIndices;
            usedIndices.reset();
  
            for (size_t byteIdx = 0; byteIdx < thisBlockSize; byteIdx++) {
@@@ -259,32 -321,41 +311,32 @@@
                    break;
                  }
                  ++it;
 -                                }
 -                                else {
 +              } else {
                  allFound = false;
                  break;
                }
              }
 -                            if (it == finalHashOut.end()) {
 -                                allFound = false;
 +            if (!allFound) {
                break;
              }
            }
 -
            if (allFound) {
              found = true;
 -                            if (verbose) {
 -                                std::cout << "Scatter Indices: ";
 -                                for (auto idx : scatterIndices) {
 -                                    std::cout << static_cast<uint16_t>(idx) << " ";
 -                                }
 -                                std::cout << std::endl;
            }
 -                        }
 -                    }
 -                    else if (searchModeEnum == 0x04) { // mapscatter
 -                        // Reset offsets
 -                        std::fill(std::begin(reverseMapOffsets), std::end(reverseMapOffsets), 0);
 +        } else if (searchModeEnum == 0x04) { // mapscatter
 +          bool allFound = true;
 +          static uint8_t reverseMap[256 * 256];
 +          static uint8_t reverseMapOffsets[256];
  
 -                        // Fill the map with all positions of each byte in finalHashOut
 +          memset(reverseMapOffsets, 0, sizeof(reverseMapOffsets));
 +
 +          // Build map
            for (uint16_t i = 0; i < finalHashOut.size(); i++) {
              uint8_t b = finalHashOut[i];
              reverseMap[b * 256 + reverseMapOffsets[b]] = i;
              reverseMapOffsets[b]++;
            }
  
 -                        bool allFound = true;
            for (size_t byteIdx = 0; byteIdx < thisBlockSize; ++byteIdx) {
              uint8_t targetByte = block[byteIdx];
              if (reverseMapOffsets[targetByte] == 0) {
@@@ -295,325 -366,275 +347,325 @@@
              scatterIndices[byteIdx] =
                reverseMap[targetByte * 256 + reverseMapOffsets[targetByte]];
            }
 -
            if (allFound) {
              found = true;
 -                            if (verbose) {
 -                                std::cout << "Scatter Indices: ";
 -                                for (auto idx : scatterIndices) {
 -                                    std::cout << static_cast<uint16_t>(idx) << " ";
 -                                }
 -                                std::cout << std::endl;
 -                            }
            }
          }
  
          if (found) {
 -                        // For non-parallel modes, write nonce and indices
 -                        fout.write(reinterpret_cast<const char*>(chosenNonce.data()), nonceSize);
 -                        if (searchModeEnum == 0x02 || searchModeEnum == 0x03 || searchModeEnum == 0x04) {
 -                            fout.write(reinterpret_cast<const char*>(scatterIndices.data()), scatterIndices.size() * sizeof(uint16_t));
 -
 -                        }
 -                        else {
 -                            // prefix or sequence
 +          // Write nonce
 +          outBuffer.insert(outBuffer.end(), chosenNonce.begin(), chosenNonce.end());
 +          // Write indices
 +          if (searchModeEnum == 0x02 || searchModeEnum == 0x03 ||
 +              searchModeEnum == 0x04) {
 +            const uint8_t* si = reinterpret_cast<const uint8_t*>(scatterIndices.data());
 +            outBuffer.insert(outBuffer.end(), si, si + scatterIndices.size() * sizeof(uint16_t));
 +          } else if (searchModeEnum == 0x00 || searchModeEnum == 0x01) {
              uint16_t startIdx = scatterIndices[0];
 -                            fout.write(reinterpret_cast<const char*>(&startIdx), sizeof(startIdx));
 +            const uint8_t* idxPtr = reinterpret_cast<const uint8_t*>(&startIdx);
 +            outBuffer.insert(outBuffer.end(), idxPtr, idxPtr + sizeof(startIdx));
            }
 -                        break; // done with this block
 +          if (verbose) {
 +            std::cerr << "\r[Enc] Block " << blockIndex + 1 << "/" << totalBlocks << " found pattern.\n";
 +          }
 +          break;
          }
  
 -                    // Periodic progress for non-parallel tries
 -                    if (tries % progressInterval == 0) {
 +        if (tries % progressInterval == 0 && verbose) {
            std::cerr << "\r[Enc] Mode: " << searchMode
                      << ", Block " << (blockIndex + 1) << "/" << totalBlocks
                      << ", " << tries << " tries..." << std::flush;
          }
 -                } // end tries loop
 -
 -                // Display block progress
 -                if (verbose) {
 -                    std::cerr << "\r[Enc] Block " << blockIndex + 1 << "/" << totalBlocks << " processed.\n";
 +      }
 +    }
    }
  
 -            } // end else (other modes)
 -
 -        } // end block loop
 -
 -        fout.close();
 -        std::cout << "\n[Enc] Block-based puzzle encryption with subkeys complete: " << outFilename << "\n";
 +  // Return the fully built buffer
 +  return outBuffer;
  }
  
 -  // encrypt/decrypt block mode
 -    static void puzzleDecryptFileWithHeader(
 -        const std::string &inFilename,
 -        const std::string &outFilename,
 +static std::vector<uint8_t> puzzleDecryptBufferWithHeader(
 +  const std::vector<uint8_t> &cipherData,
    const std::string &key
  ) {
 -        // 1) Open input file & read FileHeader
 -        std::ifstream fin(inFilename, std::ios::binary);
 -        if (!fin.is_open()) {
 -            throw std::runtime_error("Cannot open ciphertext file: " + inFilename);
 -        }
 +  // We'll parse the FileHeader from the front of cipherData
 +  // Then reconstruct the plaintext.
  
 -        // Read unified FileHeader
 -        FileHeader hdr = readFileHeader(fin);
 -        if (hdr.magic != MagicNumber) { // "RCRY"
 -            throw std::runtime_error("Invalid magic number in file header.");
 +  if (cipherData.size() < sizeof(FileHeader) - 32) {
 +    throw std::runtime_error("Cipher data too small to contain valid header.");
    }
  
 -        // Determine cipher mode
 -        if (hdr.cipherMode != 0x11) { // 0x11 = Block Cipher Mode
 -            throw std::runtime_error("File is not in Block Cipher mode (expected cipherMode=0x11).");
 +  size_t offset = 0;
 +  auto readAndAdvance = [&](void* dst, size_t len) {
 +    if (offset + len > cipherData.size()) {
 +      throw std::runtime_error("Buffer overrun reading cipher data.");
      }
 +    std::memcpy(dst, &cipherData[offset], len);
 +    offset += len;
 +  };
  
 -        // Validate hash algorithm
 +  FileHeader hdr{};
 +  // Magic
 +  readAndAdvance(&hdr.magic, sizeof(hdr.magic));
 +  // Version
 +  readAndAdvance(&hdr.version, sizeof(hdr.version));
 +  // cipherMode
 +  readAndAdvance(&hdr.cipherMode, sizeof(hdr.cipherMode));
 +  // blockSize
 +  readAndAdvance(&hdr.blockSize, sizeof(hdr.blockSize));
 +  // nonceSize
 +  readAndAdvance(&hdr.nonceSize, sizeof(hdr.nonceSize));
 +  // hashSizeBits
 +  readAndAdvance(&hdr.hashSizeBits, sizeof(hdr.hashSizeBits));
 +  // outputExtension
 +  readAndAdvance(&hdr.outputExtension, sizeof(hdr.outputExtension));
 +  // hashName length
 +  uint8_t hnLen = 0;
 +  readAndAdvance(&hnLen, sizeof(hnLen));
 +  hdr.hashName.resize(hnLen);
 +  if (hnLen > 0) {
 +    readAndAdvance(&hdr.hashName[0], hnLen);
 +  }
 +  // iv
 +  readAndAdvance(&hdr.iv, sizeof(hdr.iv));
 +  // saltLen
 +  readAndAdvance(&hdr.saltLen, sizeof(hdr.saltLen));
 +  hdr.salt.resize(hdr.saltLen);
 +  if (hdr.saltLen > 0) {
 +    readAndAdvance(hdr.salt.data(), hdr.saltLen);
 +  }
 +  // searchModeEnum
 +  readAndAdvance(&hdr.searchModeEnum, sizeof(hdr.searchModeEnum));
 +  // originalSize
 +  readAndAdvance(&hdr.originalSize, sizeof(hdr.originalSize));
 +  // hmac
 +  readAndAdvance(hdr.hmac.data(), hdr.hmac.size());
 +
 +  if (hdr.magic != MagicNumber) {
 +    throw std::runtime_error("Invalid magic number.");
 +  }
 +  if (hdr.cipherMode != 0x11) {
 +    throw std::runtime_error("Not block cipher mode (expected 0x11).");
 +  }
 +
 +  // Determine HashAlgorithm
    HashAlgorithm algot = HashAlgorithm::Unknown;
    if (hdr.hashName == "rainbow") {
      algot = HashAlgorithm::Rainbow;
 -        }
 -        else if (hdr.hashName == "rainstorm") {
 +  } else if (hdr.hashName == "rainstorm") {
      algot = HashAlgorithm::Rainstorm;
 -        }
 -        else {
 -            throw std::runtime_error("Unsupported hash algorithm in header: " + hdr.hashName);
 +  } else {
 +    throw std::runtime_error("Unsupported hash algorithm: " + hdr.hashName);
    }
  
 -        // Read the rest of the file as cipher data
 -        std::vector<uint8_t> cipherData(
 -            (std::istreambuf_iterator<char>(fin)),
 -            (std::istreambuf_iterator<char>())
 -        );
 -        fin.close();
 -
 -        // 2) Derive PRK using KDF
 -        // Assume 'derivePRK' and 'extendOutputKDF' are defined in tool.h and in scope
 +  // Remainder is actual block data
 +  // Derive PRK
    std::vector<uint8_t> ikm(key.begin(), key.end());
 -        // Convert seed (uint64_t) to vector<uint8_t>
    std::vector<uint8_t> seed_vec(8);
 -        uint64_t seed = hdr.iv;
    for (size_t i = 0; i < 8; ++i) {
 -            seed_vec[i] = static_cast<uint8_t>((seed >> (i * 8)) & 0xFF);
 +    seed_vec[i] = static_cast<uint8_t>((hdr.iv >> (i * 8)) & 0xFF);
    }
 +  std::vector<uint8_t> prk = derivePRK(seed_vec, hdr.salt, ikm, algot, hdr.hashSizeBits);
  
 -        std::vector<uint8_t> prk = derivePRK(
 -            seed_vec,          // Converted seed as vector<uint8_t>
 -            hdr.salt,              // Provided salt
 -            ikm,            // IKM (Input Key Material)
 -            algot,             // Hash algorithm
 -            hdr.hashSizeBits          // Hash size in bits
 -        );
 -
 -        // 3) Extend PRK into subkeys for each block
 +  // Extend into subkeys
    size_t totalBlocks = (hdr.originalSize + hdr.blockSize - 1) / hdr.blockSize;
    size_t subkeySize = hdr.hashSizeBits / 8;
    size_t totalNeeded = totalBlocks * subkeySize;
 -        std::vector<uint8_t> allSubkeys = extendOutputKDF(
 -            prk,
 -            totalNeeded,
 -            algot,
 -            hdr.hashSizeBits
 -        );
 +  std::vector<uint8_t> allSubkeys = extendOutputKDF(prk, totalNeeded, algot, hdr.hashSizeBits);
  
 -        // 4) Prepare to reconstruct plaintext
 +  // Reconstruct
    std::vector<uint8_t> plaintextAccumulated;
    plaintextAccumulated.reserve(hdr.originalSize);
  
 -        size_t cipherOffset = 0;
 -        size_t recoveredSoFar = 0;
 -
    for (size_t blockIndex = 0; blockIndex < totalBlocks; blockIndex++) {
 -            size_t thisBlockSize = std::min<size_t>(static_cast<size_t>(hdr.blockSize), hdr.originalSize - recoveredSoFar);
 -            std::vector<uint8_t> block;
 +    size_t thisBlockSize = std::min<size_t>(hdr.blockSize, hdr.originalSize - plaintextAccumulated.size());
  
 -            // 4.1) Extract storedNonce
 -            if (cipherOffset + hdr.nonceSize > cipherData.size()) {
 -                throw std::runtime_error("Unexpected end of cipher data when reading nonce.");
 +    // Read storedNonce
 +    if (offset + hdr.nonceSize > cipherData.size()) {
 +      throw std::runtime_error("Cipher data ended while reading nonce.");
      }
      std::vector<uint8_t> storedNonce(
 -                cipherData.begin() + cipherOffset,
 -                cipherData.begin() + cipherOffset + hdr.nonceSize
 +      cipherData.begin() + offset,
 +      cipherData.begin() + offset + hdr.nonceSize
      );
 -            cipherOffset += hdr.nonceSize;
 +    offset += hdr.nonceSize;
  
 -            // 4.2) Read scatterIndices or startIndex based on searchModeEnum
 +    // Read scatterIndices or startIndex
      std::vector<uint16_t> scatterIndices;
      uint16_t startIndex = 0;
      if (hdr.searchModeEnum == 0x02 || hdr.searchModeEnum == 0x03 ||
          hdr.searchModeEnum == 0x04 || hdr.searchModeEnum == 0x05) {
 -                // Series, Scatter, MapScatter, Parascatter
        size_t scatterDataSize = thisBlockSize * sizeof(uint16_t);
 -                if (cipherOffset + scatterDataSize > cipherData.size()) {
 -                    throw std::runtime_error("Unexpected end of cipher data when reading scatter indices.");
 +      if (offset + scatterDataSize > cipherData.size()) {
 +        throw std::runtime_error("Cipher data ended while reading scatter indices.");
        }
        scatterIndices.assign(
 -                    reinterpret_cast<const uint16_t*>(&cipherData[cipherOffset]),
 -                    reinterpret_cast<const uint16_t*>(&cipherData[cipherOffset + scatterDataSize])
 +        reinterpret_cast<const uint16_t*>(&cipherData[offset]),
 +        reinterpret_cast<const uint16_t*>(&cipherData[offset + scatterDataSize])
        );
 -                cipherOffset += scatterDataSize;
 -            }
 -            else {
 -                // Prefix or Sequence
 -                if (cipherOffset + 1 > cipherData.size()) {
 -                    throw std::runtime_error("Unexpected end of cipher data when reading start index.");
 +      offset += scatterDataSize;
 +    } else {
 +      // prefix or sequence
 +      if (offset + sizeof(uint16_t) > cipherData.size()) {
 +        throw std::runtime_error("Cipher data ended while reading start index.");
        }
 -                startIndex = cipherData[cipherOffset];
 -                cipherOffset += 1;
 +      // We wrote a uint16_t, but for prefix/sequence we might have only written 1 byte,
 +      // so adapt as needed if your real code only wrote 1 byte. We'll assume full 2 bytes.
 +      std::memcpy(&startIndex, &cipherData[offset], sizeof(startIndex));
 +      offset += sizeof(startIndex);
      }
  
 -            // 4.3) Derive subkey for this block
 +    // Subkey
      size_t subkeyOffset = blockIndex * subkeySize;
      if (subkeyOffset + subkeySize > allSubkeys.size()) {
 -                throw std::runtime_error("Subkey index out of range.");
 +      throw std::runtime_error("Subkey index out of range in decryption.");
      }
      std::vector<uint8_t> blockSubkey(
        allSubkeys.begin() + subkeyOffset,
        allSubkeys.begin() + subkeyOffset + subkeySize
      );
  
 -            // 4.4) Recompute the hash using blockSubkey and storedNonce
 +    // Recompute hash
      std::vector<uint8_t> trial(blockSubkey);
      trial.insert(trial.end(), storedNonce.begin(), storedNonce.end());
  
      std::vector<uint8_t> hashOut(hdr.hashSizeBits / 8);
 -            invokeHash<false>(algot, hdr.iv, trial, hashOut, hdr.hashSizeBits); // Assuming 'hdr.iv' is passed correctly
 +    invokeHash<false>(algot, hdr.iv, trial, hashOut, hdr.hashSizeBits);
  
 -            // If outputExtension > 0, extend the output
 -            std::vector<uint8_t> finalHashOut = hashOut; // Default to OG hashOut
 +    std::vector<uint8_t> finalHashOut = hashOut;
      if (hdr.outputExtension > 0) {
 -              // Derive PRK using trial, salt, and seed
 -              /*
 -              std::vector<uint8_t> prk = derivePRK(
 -                trial,              // Input key material: subkey || nonce
 -                hdr.salt,           // Salt from file header
 -                ikm,                // IKM derived from decryption call
 -                algot,              // Hash algorithm
 -                hdr.hashSizeBits    // Base hash size
 -              );
 -              */
 -
 -              // Extend the PRK to derive additional bytes (extendedOutput)
 -              size_t extendedSize = hdr.outputExtension; // Additional bytes from header
 -              std::vector<uint8_t> extendedOutput = extendOutputKDF(
 -                trial,                // PRK derived from trial
 -                extendedSize,       // Length of the extension
 -                algot,              // Hash algorithm
 -                hdr.hashSizeBits    // Original hash size
 -              );
 -
 -              // Combine hashOut and extendedOutput
 -              finalHashOut.insert(finalHashOut.end(), extendedOutput.begin(), extendedOutput.end());
 +      std::vector<uint8_t> extended = extendOutputKDF(trial, hdr.outputExtension, algot, hdr.hashSizeBits);
 +      finalHashOut.insert(finalHashOut.end(), extended.begin(), extended.end());
      }
  
 -            // 4.5) Reconstruct plaintext block based on searchModeEnum
 -            if (hdr.searchModeEnum == 0x00) { // Prefix
 -                if (finalHashOut.size() < thisBlockSize/sizeof(uint16_t)) {
 -                    throw std::runtime_error("[Dec] Hash output smaller than block size for Prefix mode.");
 +    // Reconstruct block
 +    std::vector<uint8_t> block;
 +    block.reserve(thisBlockSize);
 +
 +    if (hdr.searchModeEnum == 0x00) { // prefix
 +      if (finalHashOut.size() < thisBlockSize) {
 +        throw std::runtime_error("Hash output smaller than block size in prefix mode.");
        }
        block.assign(finalHashOut.begin(), finalHashOut.begin() + thisBlockSize);
 +    } else if (hdr.searchModeEnum == 0x01) { // sequence
 +      if (startIndex + thisBlockSize > finalHashOut.size()) {
 +        throw std::runtime_error("Start index out of bounds in sequence mode.");
        }
 -            else if (hdr.searchModeEnum == 0x01) { // Sequence
 -                if (startIndex + thisBlockSize/sizeof(uint16_t) > finalHashOut.size()) {
 -                    throw std::runtime_error("[Dec] Start index out of bounds in Sequence mode.");
 -                }
 -                block.assign(finalHashOut.begin() + startIndex, finalHashOut.begin() + startIndex + thisBlockSize);
 -            }
 -            else if (hdr.searchModeEnum == 0x02 || hdr.searchModeEnum == 0x03 ||
 -                     hdr.searchModeEnum == 0x04 || hdr.searchModeEnum == 0x05) { // Series, Scatter, MapScatter, Parascatter
 -                block.reserve(thisBlockSize);
 +      block.assign(finalHashOut.begin() + startIndex,
 +                   finalHashOut.begin() + startIndex + thisBlockSize);
 +    } else if (hdr.searchModeEnum == 0x02 || hdr.searchModeEnum == 0x03 ||
 +               hdr.searchModeEnum == 0x04 || hdr.searchModeEnum == 0x05) {
        for (size_t j = 0; j < thisBlockSize; j++) {
          uint16_t idx = scatterIndices[j];
          if (idx >= finalHashOut.size()) {
 -                        // std::cerr << "idx " << idx << " final hash out size " << finalHashOut.size() << std::flush;
 -                        throw std::runtime_error("[Dec] Scatter index out of range.");
 +          throw std::runtime_error("Scatter index out of range in finalHashOut.");
          }
          block.push_back(finalHashOut[idx]);
        }
 -            }
 -            else {
 -                throw std::runtime_error("Invalid search mode enum in decryption.");
 +    } else {
 +      throw std::runtime_error("Invalid searchModeEnum in decryption.");
      }
  
 -            // 4.6) Accumulate the reconstructed block
 -            plaintextAccumulated.insert(
 -                plaintextAccumulated.end(),
 -                block.begin(),
 -                block.end()
 -            );
 -            recoveredSoFar += thisBlockSize;
 +    plaintextAccumulated.insert(plaintextAccumulated.end(), block.begin(), block.end());
  
 -            // 4.7) Progress Reporting
      if (blockIndex % 100 == 0) {
 -                std::cerr << "\r[Dec] Processing block " << (blockIndex + 1) << " / " << totalBlocks << "..." << std::flush;
 +      std::cerr << "\r[Dec] Processing block " << (blockIndex + 1) << "/" << totalBlocks << "...";
 +    }
    }
 -        } // end for(blockIndex)
 -
 -        std::cout << "\n[Dec] Ciphertext blocks decrypted successfully.\n";
  
 -        // 5) Decompress the accumulated plaintext
 -        std::vector<uint8_t> decompressedData = decompressData(plaintextAccumulated);
 +  // Done reading, now decompress
 +  //std::vector<uint8_t> decompressedData = decompressData(plaintextAccumulated);
 +  std::vector<uint8_t> decompressedData = plaintextAccumulated;
    if (plaintextAccumulated.size() != hdr.originalSize) {
 -            throw std::runtime_error("Compressed data size does not match original size.");
 +    throw std::runtime_error("Compressed data size mismatch vs. original size header.");
 +  }
 +
 +  return decompressedData;
  }
  
 -        // 6) Write the decompressed plaintext to output file
 +static void puzzleEncryptFileWithHeader(
 +  const std::string &inFilename,
 +  const std::string &outFilename,
 +  const std::string &key,
 +  HashAlgorithm algot,
 +  uint32_t hash_size,
 +  uint64_t seed,
 +  std::vector<uint8_t> salt,
 +  size_t blockSize,
 +  size_t nonceSize,
 +  const std::string &searchMode,
 +  bool verbose,
 +  bool deterministicNonce,
 +  uint32_t outputExtension
 +) {
 +  // 1) Read & compress plaintext from file
 +  std::ifstream fin(inFilename, std::ios::binary);
 +  if (!fin.is_open()) {
 +    throw std::runtime_error("Cannot open input file: " + inFilename);
 +  }
 +  std::vector<uint8_t> plainData(
 +    (std::istreambuf_iterator<char>(fin)),
 +    (std::istreambuf_iterator<char>())
 +  );
 +  fin.close();
 +
 +  // 2) Call the new buffer-based API
 +  std::vector<uint8_t> encrypted = puzzleEncryptBufferWithHeader(
 +    plainData,
 +    key,
 +    algot,
 +    hash_size,
 +    seed,
 +    salt,
 +    blockSize,
 +    nonceSize,
 +    searchMode,
 +    verbose,
 +    deterministicNonce,
 +    outputExtension
 +  );
 +
 +  // 3) Write the resulting ciphertext to file
    std::ofstream fout(outFilename, std::ios::binary);
    if (!fout.is_open()) {
 -            throw std::runtime_error("Cannot open output file for decompressed plaintext: " + outFilename);
 +    throw std::runtime_error("Cannot open output file: " + outFilename);
    }
 +  fout.write(reinterpret_cast<const char*>(encrypted.data()), encrypted.size());
 +  fout.close();
  
 +  std::cout << "\n[Enc] Block-based puzzle encryption with subkeys complete: " << outFilename << "\n";
 +}
 +
 +static void puzzleDecryptFileWithHeader(
 +  const std::string &inFilename,
 +  const std::string &outFilename,
 +  const std::string &key
 +) {
 +  // 1) Read the ciphertext file
 +  std::ifstream fin(inFilename, std::ios::binary);
 +  if (!fin.is_open()) {
 +    throw std::runtime_error("Cannot open ciphertext file: " + inFilename);
 +  }
 +  std::vector<uint8_t> cipherData(
 +    (std::istreambuf_iterator<char>(fin)),
 +    (std::istreambuf_iterator<char>())
 +  );
 +  fin.close();
 +
 +  // 2) Call the new buffer-based API
 +  std::vector<uint8_t> decompressedData = puzzleDecryptBufferWithHeader(
 +    cipherData,
 +    key
 +  );
 +
 +  // 3) Write the decompressed plaintext to file
 +  std::ofstream fout(outFilename, std::ios::binary);
 +  if (!fout.is_open()) {
 +    throw std::runtime_error("Cannot open output file for plaintext: " + outFilename);
 +  }
    fout.write(reinterpret_cast<const char*>(decompressedData.data()), decompressedData.size());
    fout.close();
  
    std::cout << "[Dec] Decompressed plaintext written to: " << outFilename << "\n";
  }
 +
